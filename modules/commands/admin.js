const { readdirSync, readFileSync, writeFileSync, existsSync } = require("fs-extra");
const { resolve } = require("path");

module.exports.config = {
    name: "admin",
    version: "1.0.6",
    hasPermssion: 1,
    credits: "Mirai Team - Modified by Satoru",
    description: "Qu·∫£n l√Ω v√† c·∫•u h√¨nh ADMIN BOT",
    commandCategory: "H·ªá th·ªëng",
    usages: "< add/remove | Super Admin & Admin > | < list/only/ibrieng >",
    cooldowns: 2,
    dependencies: {
        "fs-extra": ""
    }
};

module.exports.languages = {
    "vi": {
        "listAdmin": `[ DANH S√ÅCH ADMIN & NG∆Ø·ªúI H·ªñ TR·ª¢ ] \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  [ ADMIN BOT ] \n%1\n\n  [ NG∆Ø·ªúI H·ªñ TR·ª¢ ] \n%2\n\nReply s·ªë th·ª© t·ª± ƒë·ªÉ x√≥a ƒë·ªëi t∆∞·ª£ng t∆∞∆°ng ·ª©ng.`,
        "notHavePermssion": '[ ADMIN ] ‚Üí B·∫°n kh√¥ng ƒë·ªß quy·ªÅn h·∫°n ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng "%1"',
        "addedSuccess": '[ ADMIN ] ‚Üí ƒê√£ th√™m %1 ng∆∞·ªùi d√πng tr·ªü th√†nh %2:\n\n%3',
        "removedSuccess": '[ ADMIN ] ‚Üí ƒê√£ g·ª° vai tr√≤ %1 c·ªßa %2 ng∆∞·ªùi d√πng:\n\n%3',
        "removedByIndex": '[ ADMIN ] ‚Üí ƒê√£ g·ª° th√†nh c√¥ng %1:\n%2',
        "invalidIndex": '[ ADMIN ] ‚Üí S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá!'
    }
};

module.exports.onLoad = function() {
    const pathData = resolve(__dirname, 'data', 'dataAdbox.json');
    if (!existsSync(pathData)) {
        const obj = {
            adminOnly: {},
            adminbox: {},
            only: {},
            privateChat: {}
        };
        writeFileSync(pathData, JSON.stringify(obj, null, 4));
    }
};

module.exports.handleReply = async function({ api, event, handleReply, getText, Users }) {
    if (event.senderID != handleReply.author) return;
    const { threadID, messageID, body } = event;
    const { configPath } = global.client;
    const config = require(configPath);
    
    const index = parseInt(body);
    if (isNaN(index)) return api.sendMessage(getText("invalidIndex"), threadID, messageID);
    
    let targetArray, targetIndex, roleText;
    const adminLength = config.ADMINBOT.length;
    
    if (index <= adminLength) {
        targetArray = config.ADMINBOT;
        targetIndex = index - 1;
        roleText = "ADMIN BOT";
    } else {
        targetArray = config.NDH;
        targetIndex = index - adminLength - 1;
        roleText = "NG∆Ø·ªúI H·ªñ TR·ª¢";
    }
    
    if (targetIndex < 0 || targetIndex >= targetArray.length) {
        return api.sendMessage(getText("invalidIndex"), threadID, messageID);
    }
    
    const removedUID = targetArray[targetIndex];
    const name = await Users.getNameUser(removedUID);
    
    targetArray.splice(targetIndex, 1);
    if (roleText === "ADMIN BOT") {
        global.config.ADMINBOT.splice(global.config.ADMINBOT.indexOf(removedUID), 1);
    } else {
        global.config.NDH.splice(global.config.NDH.indexOf(removedUID), 1);
    }
    
    writeFileSync(configPath, JSON.stringify(config, null, 4), 'utf8');
    
    return api.sendMessage(
        getText("removedByIndex", roleText, `${removedUID} - ${name}`),
        threadID,
        messageID
    );
};

module.exports.run = async function({ api, event, args, Users, permssion, getText }) {
    const { threadID, messageID, mentions, senderID } = event;
    const { configPath } = global.client;
    const config = require(configPath);
    const mention = Object.keys(mentions);
    
    if (!args[0]) {
        return api.sendMessage(
            `[ S√çT TING A ƒê·ªú MIN ]\n\n` +
            `üìê admin list: Xem danh s√°ch qu·∫£n l√Ω\n` +
            `üë§ admin add: Th√™m qu·∫£n tr·ªã vi√™n\n` +
            `üêã admin remove: G·ª° qu·∫£n tr·ªã vi√™n\n` +
            `ü§ñ admin addndh: Th√™m ng∆∞·ªùi h·ªó tr·ª£\n` +
            `üëæ admin removendh: G·ª° ng∆∞·ªùi h·ªó tr·ª£\n` +
            `üîí admin qtvonly: B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô QTV\n` +
            `‚öíÔ∏è admin only: B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô Admin\n` +
            `üõ°Ô∏è admin ibrieng: B·∫≠t/t·∫Øt chat ri√™ng\n` +
            `üõÑ admin ship: cho m·∫•y th·∫±ng l·ªìn b√∫ mdl\n` +
            `üèß admin echo:  ƒë√©o bi·∫øt ƒë·ªÉ ki·ªÉu j\n` +
            `‚ôê admin fats:  ƒëo t·ªëc ƒë·ªô c·ªßa m·∫°ng hay ph·∫£n h·ªìi c·ªßa bot hay cc j ƒë√≥ \n\n` +
            ``,
            threadID, messageID);
           }

    const getUids = async (type) => {
        let uids = [];
        if (event.type === "message_reply") {
            uids.push(event.messageReply.senderID);
        } else if (mention.length > 0) {
            uids = mention;
        } else if (args[1] && !isNaN(args[1])) {
            uids.push(args[1]);
        }
        return uids;
    };

    const addUsers = async (uids, type) => {
        const added = [];
        for (const uid of uids) {
            const name = global.data.userName.get(uid) || await Users.getNameUser(uid);
            if (type === "ADMIN" && !config.ADMINBOT.includes(uid)) {
                config.ADMINBOT.push(uid);
                global.config.ADMINBOT.push(uid);
                added.push(`${uid} - ${name}`);
            } else if (type === "NDH" && !config.NDH.includes(uid)) {
                config.NDH.push(uid);
                global.config.NDH.push(uid);
                added.push(`${uid} - ${name}`);
            }
        }
        return added;
    };

    const removeUsers = async (uids, type) => {
        const removed = [];
        for (const uid of uids) {
            const name = global.data.userName.get(uid) || await Users.getNameUser(uid);
            if (type === "ADMIN") {
                const index = config.ADMINBOT.indexOf(uid);
                if (index !== -1) {
                    config.ADMINBOT.splice(index, 1);
                    global.config.ADMINBOT.splice(global.config.ADMINBOT.indexOf(uid), 1);
                    removed.push(`${uid} - ${name}`);
                }
            } else if (type === "NDH") {
                const index = config.NDH.indexOf(uid);
                if (index !== -1) {
                    config.NDH.splice(index, 1);
                    global.config.NDH.splice(global.config.NDH.indexOf(uid), 1);
                    removed.push(`${uid} - ${name}`);
                }
            }
        }
        return removed;
    };

    switch (args[0]) {
        case "list": {
            if (permssion < 2) return api.sendMessage(getText("notHavePermssion", "list"), threadID, messageID);
            
            let adminList = [], ndhList = [];
            let count = 1;
            
            for (const id of config.ADMINBOT) {
                const name = global.data.userName.get(id) || await Users.getNameUser(id);
                adminList.push(`${count++}. ${name}\n‚Üí ID: ${id}`);
            }
            
            for (const id of config.NDH) {
                const name = global.data.userName.get(id) || await Users.getNameUser(id);
                ndhList.push(`${count++}. ${name}\n‚Üí ID: ${id}`);
            }

            return api.sendMessage(
                getText("listAdmin", adminList.join("\n\n"), ndhList.join("\n\n")),
                threadID,
                (error, info) => {
                    global.client.handleReply.push({
                        name: this.config.name,
                        messageID: info.messageID,
                        author: senderID
                    });
                },
                messageID
            );
        }

        case "add": {
            if (permssion !== 3) return api.sendMessage(getText("notHavePermssion", "add"), threadID, messageID);
            const uids = await getUids("ADMIN");
            const added = await addUsers(uids, "ADMIN");
            if (added.length > 0) {
                writeFileSync(configPath, JSON.stringify(config, null, 4), 'utf8');
                return api.sendMessage(getText("addedSuccess", added.length, "ADMIN BOT", added.join("\n")), threadID, messageID);
            }
            break;
        }

        case "addndh": {
            if (permssion !== 3) return api.sendMessage(getText("notHavePermssion", "addndh"), threadID, messageID);
            const uids = await getUids("NDH");
            const added = await addUsers(uids, "NDH");
            if (added.length > 0) {
                writeFileSync(configPath, JSON.stringify(config, null, 4), 'utf8');
                return api.sendMessage(getText("addedSuccess", added.length, "NG∆Ø·ªúI H·ªñ TR·ª¢", added.join("\n")), threadID, messageID);
            }
            break;
        }

        case "remove": {
            if (permssion !== 3) return api.sendMessage(getText("notHavePermssion", "remove"), threadID, messageID);
            const uids = await getUids("ADMIN");
            const removed = await removeUsers(uids, "ADMIN");
            if (removed.length > 0) {
                writeFileSync(configPath, JSON.stringify(config, null, 4), 'utf8');
                return api.sendMessage(getText("removedSuccess", "ADMIN BOT", removed.length, removed.join("\n")), threadID, messageID);
            }
            break;
        }

        case "removendh": {
            if (permssion !== 3) return api.sendMessage(getText("notHavePermssion", "removendh"), threadID, messageID);
            const uids = await getUids("NDH");
            const removed = await removeUsers(uids, "NDH");
            if (removed.length > 0) {
                writeFileSync(configPath, JSON.stringify(config, null, 4), 'utf8');
                return api.sendMessage(getText("removedSuccess", "NG∆Ø·ªúI H·ªñ TR·ª¢", removed.length, removed.join("\n")), threadID, messageID);
            }
            break;
        }

        case "qtvonly": {
            const pathData = resolve(__dirname, 'data', 'dataAdbox.json');
            const database = require(pathData);
            if (permssion < 1) return api.sendMessage("[ ADMIN ] ‚Üí C·∫ßn quy·ªÅn Qu·∫£n tr·ªã vi√™n tr·ªü l√™n", threadID, messageID);
            
            database.adminbox[threadID] = !database.adminbox[threadID];
            writeFileSync(pathData, JSON.stringify(database, null, 4));
            
            return api.sendMessage(
                `[ ADMIN ] ‚Üí ${database.adminbox[threadID] ? 
                    "B·∫≠t ch·∫ø ƒë·ªô QTV Only th√†nh c√¥ng" : 
                    "T·∫Øt ch·∫ø ƒë·ªô QTV Only th√†nh c√¥ng"}`,
                threadID, messageID
            );
        }

        case "only": {
            const pathData = resolve(__dirname, 'data', 'dataAdbox.json');
            const database = require(pathData);
            if (permssion < 2) return api.sendMessage("[ ADMIN ] ‚Üí C·∫ßn quy·ªÅn ADMIN tr·ªü l√™n", threadID, messageID);
            
            database.only[threadID] = !database.only[threadID];
            writeFileSync(pathData, JSON.stringify(database, null, 4));
            
            return api.sendMessage(
                `[ ADMIN ] ‚Üí ${database.only[threadID] ? 
                    "B·∫≠t ch·∫ø ƒë·ªô Admin Only th√†nh c√¥ng" : 
                    "T·∫Øt ch·∫ø ƒë·ªô Admin Only th√†nh c√¥ng"}`,
                threadID, messageID
            );
        }
       case 'ship': {
  if (!allowedUserIDs.includes(senderIDStr)) {
    return api.sendMessage(`‚ö†Ô∏è C·∫ßn quy·ªÅn admin ch√≠nh ƒë·ªÉ th·ª±c hi·ªán l·ªánh`, event.threadID, event.messageID);
  }

  const { messageReply, type } = event;

  let name = args[1];
  const commandName = args.slice(1).join(' ');

  let text, uid;
  if (type === "message_reply") {
    text = messageReply.body;
    uid = messageReply.senderID;
  } else {
    uid = event.senderID;
  }

  if (!text && !name) {
    return api.sendMessage(`[‚è∞] ‚Üí B√¢y gi·ªù l√†: ${gio}\n[üìù] ‚Üí H√£y reply ho·∫∑c tag ng∆∞·ªùi mu·ªën share`, event.threadID, event.messageID);
  }

  fs.readFile(`./modules/commands/${commandName}.js`, "utf-8", async (err, data) => {
    if (err) {
      return api.sendMessage(`[‚è∞] ‚Üí B√¢y gi·ªù l√†: ${gio}\n[üîé] ‚Üí R·∫•t ti·∫øc mdl ${commandName} m√† b·∫°n c·∫ßn hi·ªán kh√¥ng c√≥ tr√™n h·ªá th·ªëng c·ªßa bot ${global.config.BOTNAME}`, event.threadID, event.messageID);
    }

    const response = await axios.post("https://api.mocky.io/api/mock", {
      "status": 200,
      "content": data,
      "content_type": "application/json",
      "charset": "UTF-8",
      "secret": "PhamMinhDong",
      "expiration": "never"
    });
    
    const link = response.data.link;
    const use = await Users.getNameUser(uid);
    api.sendMessage(`[üìú] ‚Üí Nh√≥m: ${global.data.threadInfo.get(event.threadID).threadName}\n[‚è∞] ‚Üí V√†o l√∫c: ${gio}\n[üíº] ‚Üí T√™n l·ªánh: ${commandName}\n[üë§] ‚Üí Admin: ${nd}\n[üìå] ‚Üí ƒê√£ g·ª≠i module ‚òëÔ∏è\n[üìù] ‚Üí ${use} vui l√≤ng check tin nh·∫Øn ch·ªù ho·∫∑c spam ƒë·ªÉ nh·∫≠n module`, event.threadID, event.messageID);
    api.sendMessage(`[‚è∞] ‚Üí V√†o l√∫c: ${gio}\n[üîó] ‚Üí Link: ${link}\n[üî∞] ‚Üí T√™n l·ªánh: ${commandName}\n[üìú] ‚Üí Nh√≥m: ${global.data.threadInfo.get(event.threadID).threadName}\n[üîé] ‚Üí B·∫°n ƒë∆∞·ª£c admin share ri√™ng m·ªôt module`, uid);
  });

  break;
}
case 'echo': {
      const input = args.join(" ");
      const spaceIndex = input.indexOf(' ');

      if (spaceIndex !== -1) {
        const textAfterFirstWord = input.substring(spaceIndex + 1).trim();
        return api.sendMessage(textAfterFirstWord, event.threadID);
      }
      break;
    }
  case 'fast': {
      try {
        const fast = require("fast-speedtest-api");
        const speedTest = new fast({
          token: "YXNkZmFzZGxmbnNkYWZoYXNkZmhrYWxm",
          verbose: false,
          timeout: 10000,
          https: true,
          urlCount: 5,
          bufferSize: 8,
          unit: fast.UNITS.Mbps
        });
        const result = await speedTest.getSpeed();
        return api.sendMessage(`üöÄ Speed Test: ${result} Mbps`, event.threadID, event.messageID);
      } catch (error) {
        return api.sendMessage("‚ö†Ô∏è Kh√¥ng th·ªÉ ƒëo t·ªëc ƒë·ªô ngay l√∫c n√†y, h√£y th·ª≠ l·∫°i sau!", event.threadID, event.messageID);
      }
      break;
    }
 case 'create': {
      if (!allowedUserIDs.includes(senderIDStr)) {
        return api.sendMessage(`‚ö†Ô∏è C·∫ßn quy·ªÅn admin ch√≠nh ƒë·ªÉ th·ª±c hi·ªán l·ªánh`, event.threadID, event.messageID);
      }

      if (args.slice(1).length === 0) return api.sendMessage("‚ö†Ô∏è Vui l√≤ng ƒë·∫∑t t√™n cho file c·ªßa b·∫°n", event.threadID);

      const commandName = args.slice(1).join(' ');
      const filePath = `${__dirname}/${commandName}.js`;

      if (fs.existsSync(filePath)) {
        return api.sendMessage(`‚ö†Ô∏è File ${commandName}.js ƒë√£ t·ªìn t·∫°i t·ª´ tr∆∞·ªõc`, event.threadID, event.messageID);
      }

      fs.copySync(`${__dirname}/example.js`, filePath);
      return api.sendMessage(`‚òëÔ∏è ƒê√£ t·∫°o th√†nh c√¥ng file "${commandName}.js"`, event.threadID, event.messageID);
      break;
    }

        case "ibrieng": {
            const pathData = resolve(__dirname, 'data', 'dataAdbox.json');
            const database = require(pathData);
            if (permssion !== 3) return api.sendMessage("[ ADMIN ] ‚Üí C·∫ßn quy·ªÅn ADMIN ƒë·ªÉ th·ª±c hi·ªán", threadID, messageID);
            
            database.privateChat[threadID] = !database.privateChat[threadID];
            writeFileSync(pathData, JSON.stringify(database, null, 4));
            
            return api.sendMessage(
                `[ ADMIN ] ‚Üí ${database.privateChat[threadID] ? 
                    "B·∫≠t ch·∫ø ƒë·ªô chat ri√™ng th√†nh c√¥ng" : 
                    "T·∫Øt ch·∫ø ƒë·ªô chat ri√™ng th√†nh c√¥ng"}`,
                threadID, messageID
            );
        }

        default: {
            return api.sendMessage("[ ADMIN ] ‚Üí L·ªánh kh√¥ng h·ª£p l·ªá! G√µ 'admin' ƒë·ªÉ xem h∆∞·ªõng d·∫´n", threadID, messageID);
        }
    }
};
